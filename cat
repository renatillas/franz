Creating topic: test_create_success_12345
[32m.[39mFirst create result
Second create result (should fail)
Got expected TopicAlreadyExists error
[32m.[39m[32m.[39m[32m.[39m[32m.[39m
[1m[31massert[39m[22m [90mtest/franz_test.gleam:103[39m
[36m test[39m: franz_test.producer_produce_sync_test
[36m code[39m: assert Ok(Nil)
    == producer.produce_sync(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
    )
[36m left[39m: [90mliteral[39m
[36mright[39m: Error(ProducerNotFound("test_topic", 0))
[36m info[39m: Assertion failed.

[1m[31massert[39m[22m [90mtest/franz_test.gleam:120[39m
[36m test[39m: franz_test.producer_produce_sync_offset_test
[36m code[39m: assert Ok(0)
    == producer.produce_sync_offset(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
    )
[36m left[39m: [90mliteral[39m
[36mright[39m: Error(ProducerNotFound("test_topic"))
[36m info[39m: Assertion failed.

[1m[31massert[39m[22m [90mtest/franz_test.gleam:139[39m
[36m test[39m: franz_test.producer_produce_cb_test
[36m code[39m: assert Ok(producer.Partition(0))
    == producer.produce_cb(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
      callback: fn(partition, offset) {
        process.send(offset_subject, offset)
        process.send(partition_subject, partition)
      },
    )
[36m left[39m: [90mliteral[39m
[36mright[39m: Error(ProducerNotFound("test_topic", 0))
[36m info[39m: Assertion failed.

[1m[31massert[39m[22m [90mtest/franz_test.gleam:165[39m
[36m test[39m: franz_test.produce_no_ack_test
[36m code[39m: assert Ok(Nil)
    == producer.produce_no_ack(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
    )
[36m left[39m: [90mliteral[39m
[36mright[39m: Error(ProducerNotFound("test_topic", 0))
[36m info[39m: Assertion failed.
[32m.[39m
[1m[31mlet assert[39m[22m [90mtest/franz_test.gleam:225[39m
[36m test[39m: franz_test.start_topic_subscriber_test
[36m code[39m: let assert Ok(Nil) =
    producer.produce_sync(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
    )
[36mvalue[39m: Error(ProducerNotFound("test_topic", 0))
[36m info[39m: Pattern match failed, no pattern matched the value.

[1m[31massert[39m[22m [90mtest/franz_test.gleam:286[39m
[36m test[39m: franz_test.start_group_subscriber_test
[36m code[39m: assert Ok(Nil)
    == producer.produce_sync(
      client: client,
      topic: "test_topic",
      partition: producer.Partition(0),
      key: <<"key">>,
      value: producer.Value(<<"value">>, []),
    )
[36m left[39m: [90mliteral[39m
[36mright[39m: Error(ProducerNotFound("test_topic", 0))
[36m info[39m: Assertion failed.

[1m[31mlet assert[39m[22m [90mtest/franz_test.gleam:340[39m
[36m test[39m: franz_test.supervised_client_test
[36m code[39m: let assert Ok(franz.KafkaMessage(
    offset,
    <<"key">>,
    <<"value">>,
    franz.Create,
    _timestamp,
    [],
  )) = process.receive(message_subject, 1000)
[36mvalue[39m: Error(Nil)
[36m info[39m: Pattern match failed, no pattern matched the value.
[32m.[39m[32m.[39m[32m.[39m[32m.[39m[32m.[39m[32m.[39m[32m.[39m=ERROR REPORT==== 23-Aug-2025::13:56:13.561833 ===
** Generic server <0.265.0> terminating 
** Last message in was {'DOWN',#Ref<0.3645389796.3087007757.43313>,process,
                           {'start_group_subscriber:client$4613',
                               nonode@nohost},
                           normal}
** When Server state == {state,'start_group_subscriber:client$4613',
                         #Ref<0.3645389796.3087007757.43313>,<<"test_topic">>,
                         [{consumer,0,<0.267.0>,
                           #Ref<0.3645389796.3087007748.44516>,undefined,
                           undefined}],
                         brod_group_subscriber_worker,
                         {state,
                          #{partition => 0,
                            cb_module => franz_group_subscriber_cb_fun,
                            group_id => <<"test_group">>,
                            begin_offset => undefined,
                            topic => <<"test_topic">>,
                            ack_fun =>
                             #Fun<brod_group_subscriber_v2.4.57032487>,
                            cb_config =>
                             {cbm_init_data,#Fun<franz_test.10.109745151>,0},
                            commit_fun =>
                             #Fun<brod_group_subscriber_v2.3.57032487>},
                          franz_group_subscriber_cb_fun,
                          {#Fun<franz_test.10.109745151>,0},
                          #Fun<brod_group_subscriber_v2.3.57032487>},
                         message}
** Reason for termination ==
** client_down

[31m
13 tests, 7 failures[39m
=ERROR REPORT==== 23-Aug-2025::13:56:13.561741 ===
** Generic server <0.234.0> terminating 
** Last message in was {'DOWN',#Ref<0.3645389796.3087007757.43192>,process,
                               {'topic_subscriber:client$4357',nonode@nohost},
                               normal}
** When Server state == {state,'topic_subscriber:client$4357',
                            #Ref<0.3645389796.3087007757.43192>,
                            <<"test_topic">>,
                            [{consumer,0,<0.236.0>,
                                 #Ref<0.3645389796.3087007757.43250>,0,
                                 undefined}],
                            brod_topic_subscriber_cb_fun,
                            {#Fun<franz_test.11.109745151>,0},
                            message}
** Reason for termination ==
** client_down

